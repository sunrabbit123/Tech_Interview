(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{286:function(t,e,v){"use strict";v.r(e);var _=v(14),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"db-관련-요모조모"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#db-관련-요모조모"}},[t._v("#")]),t._v(" DB 관련 요모조모")]),t._v(" "),e("h2",{attrs:{id:"목차"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#목차"}},[t._v("#")]),t._v(" 목차")]),t._v(" "),e("h3",{attrs:{id:"elasticsearch의-키워드-검색과-rdbms에서-like-검색의-차이점"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch의-키워드-검색과-rdbms에서-like-검색의-차이점"}},[t._v("#")]),t._v(" ElasticSearch의 키워드 검색과 RDBMS에서 %LIKE% 검색의 차이점")]),t._v(" "),e("Detail",[e("p",[t._v("RDBMS에서의 "),e("code",[t._v("%LIKE%")]),t._v(" 검색은 이 글을 보는 대부분은 아시겠지만,\n중간에 해당 단어가 들어간 것들만 나오도록 필터링을 한 것 입니다.")]),t._v(" "),e("p",[t._v("ElasticSearch에서의 검색은 "),e("code",[t._v("역색인(inverted index)")]),t._v(" 방식을 이용합니다.")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("색인(Index)")]),t._v("은 키워드를 찾아보기 쉽도록 정렬 및 나열한 것 입니다.\n"),e("code",[t._v("역색인(Inverted Index)")]),t._v("은 키워드를 통해 문서를 찾아내는 방식입니다.")])]),t._v(" "),e("p",[t._v("이러한 역색인 방식은 "),e("code",[t._v("검색 키워드")]),t._v("를 통해 보다 빨리 원하는 문서를 찾아낼 수 있게됩니다.")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("%LIKE%")]),t._v(" 검색은 "),e("code",[t._v("Full Text Search")]),t._v("인 반면\n역색인방식은 전처리가 있기에, 후에 검색속도가 빨라지는 형태다.")])])]),t._v(" "),e("h3",{attrs:{id:"rdmbs에서-index가-어떻게-구성되어있는가"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdmbs에서-index가-어떻게-구성되어있는가"}},[t._v("#")]),t._v(" RDMBS에서 INDEX가 어떻게 구성되어있는가?")]),t._v(" "),e("Detail",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("`Index`는 색인, 보통 책의 목차의 역할정도다.\n원하는 것이 있으면 보고 페이지(주소)를 따라가 열람 하는 것\n\n그러기에 테이블을 검색하는 속도나 성능이 향상됩니다.\n또한 데이터들이 정렬되어있기에 보다 편하게 가져올 수 있습니다.\n\n\n하지만 이러한 인덱스를 관리하기 위해서 추가 작업이 필요하며\n추가 저장공간이 필요하고, 잘못 사용하는 경우 오히려 검색 성능만 저하됩니다.\n")])])])]),t._v(" "),e("h3",{attrs:{id:"rdb와-nosql의-차이점"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb와-nosql의-차이점"}},[t._v("#")]),t._v(" RDB와 NoSQL의 차이점")]),t._v(" "),e("Detail",[e("p",[t._v("RDB와 NoSQL의 대표적인 차이점으로 두가지를 꼽을 수 있다.")]),t._v(" "),e("ol",[e("li",[t._v("관계의 유무")]),t._v(" "),e("li",[t._v("SQL 사용 유무")])]),t._v(" "),e("p",[t._v("NoSQL의 의미는 non Relational 이라는 의미가 크다\nRDB보다 덜 제한적인 일관성 모델의 데이터 저장 및 검색을 위한 환경을 제공해준다.")]),t._v(" "),e("p",[t._v("이 중 유명한 것은 MongoDB, Redis 등이 있다.")]),t._v(" "),e("p",[e("code",[t._v("MongoDB")]),t._v("는 문서지향적, "),e("code",[t._v("Redis")]),t._v("는 키-값의 형태를 띈다.")]),t._v(" "),e("p",[t._v("본론으로 돌아와 둘의 차이점에는 관계의 유무가 큰 영향을 끼친다.\n"),e("code",[t._v("NoSQL")]),t._v("은 데이터 구조를 알 수 없으며, 확장 및 축소가 중요하다면 사용하는게 좋으며\n데이터 구조가 명확하며, 명확한 스키마가 중요하다면 "),e("code",[t._v("RDB")]),t._v("를 사용하는 것이 좋다.")])]),t._v(" "),e("h3",{attrs:{id:"어트리뷰트가-굉장히-많은-테이블을-설계해야한다-어떻게-설계할-것-인가"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#어트리뷰트가-굉장히-많은-테이블을-설계해야한다-어떻게-설계할-것-인가"}},[t._v("#")]),t._v(" 어트리뷰트가 굉장히 많은 테이블을 설계해야한다. 어떻게 설계할 것 인가?")]),t._v(" "),e("Detail",[e("ol",[e("li",[t._v("Master - slave, 스토리지 사용, 카디널리티 기준 인덱싱 선정")]),t._v(" "),e("li",[t._v("인덱싱 성능 검사")]),t._v(" "),e("li",[t._v("explain 사용")])])]),t._v(" "),e("h3",{attrs:{id:"커버링-인덱스란"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#커버링-인덱스란"}},[t._v("#")]),t._v(" 커버링 인덱스란?")]),t._v(" "),e("Detail",[e("p",[t._v("사전적 의미로는 다음과 같다.")]),t._v(" "),e("blockquote",[e("p",[t._v("쿼리를 충족하는데 필요한 모든 데이터를 갖는 인덱스")])]),t._v(" "),e("p",[t._v("그럼 이게 무엇이냐\n쿼리에 쓰이는 "),e("code",[t._v("where")]),t._v(", "),e("code",[t._v("Group By")]),t._v(", "),e("code",[t._v("Order By")]),t._v("에 쓰이는 모든 컬럼들이 인덱스의 구성요소인 것 이다.")]),t._v(" "),e("h4",{attrs:{id:"clustered-key-non-clustered-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#clustered-key-non-clustered-key"}},[t._v("#")]),t._v(" Clustered Key, Non Clustered Key")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}}),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("대상")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("제한")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Clustered")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("PK, 없다면 UK, 얘도 없다면 Hidden Key 생성")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("한 테이블에 하나")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Non Clustered")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("일반적인 인덱스")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("제한 없음")])])])]),t._v(" "),e("p",[t._v("대충 DB에 있는 데이터에 접근 할 때 두가지 경우로 나뉜다.")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("Index")]),t._v("로 접근 시 Non CLustered Key가 갖고 있는 실제 레코드 주소값(Clustered Key)을 이용하여 재조회")]),t._v(" "),e("li",[e("code",[t._v("PK")]),t._v(", 즉 Clustered Key로 접근 시, 즉시 데이터 블록에 접근")])]),t._v(" "),e("p",[t._v("그러기에 우리는 "),e("code",[t._v("PK")]),t._v("를 이용하여 조회할 경우 빠르게 데이터를 받아볼 수 있다.")]),t._v(" "),e("blockquote",[e("p",[t._v("MySQL에서는 Non-clustered Key에 Clustered Key가 항상 포함되어 있다.")])]),t._v(" "),e("h4",{attrs:{id:"그래서-커버링인덱스는"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#그래서-커버링인덱스는"}},[t._v("#")]),t._v(" 그래서 커버링인덱스는?")]),t._v(" "),e("p",[t._v("결론으로 돌아오자면, 커버링 인덱스는 재조회 단계가 없도록 인덱스들로만 쿼리문을 작성하는 것이다.")])])],1)}),[],!1,null,null,null);e.default=a.exports}}]);